{
	"script": [
		"class SpreadingPos(int*(x, y, z), byte direction)",
		"",
		"int directionX(int index: index == 0 ? -1 : index == 1 ? 1 : 0)",
		"int directionY(int index: index == 2 ? -1 : index == 3 ? 1 : 0)",
		"int directionZ(int index: index == 4 ? -1 : index == 5 ? 1 : 0)",
		"",
		"unless (getBlockState(originX, originY, originZ).isReplaceable(): return(false))",
		"ArrayList spreadingPositions = null",
		"HashSet sculkPosAdjacents = null",
		"",
		"SpreadingPos nextSpreadingPos(:",
			"int count = spreadingPositions.size()",
			"if (count == 0: return(null))",
			"int index = random.nextInt(count)",
			"--count",
			"SpreadingPos result = (",
				"index == count",
				"? spreadingPositions.removeIndex(index)",
				": spreadingPositions.set(index, spreadingPositions.removeIndex(count))",
			")",
			"sculkPosAdjacents.add(result)",
			"return(result)",
		")",
		"",
		"void addSpreadingPos(SpreadingPos pos:",
			"if (sculkPosAdjacents.add(pos): spreadingPositions.add(pos))",
		")",
		"",
		"for (int direction in range[0, 6):",
			"if (",
				"getBlockState(",
					"originX + directionX(direction),",
					"originY + directionY(direction),",
					"originZ + directionZ(direction)",
				")",
				".blocksLight()",
			":",
				"(spreadingPositions ?: (spreadingPositions := new()))",
				".add(SpreadingPos.new(originX, originY, originZ, direction.as(byte)))",
			")",
		")",
		"if (spreadingPositions == null: return(false))",
		"sculkPosAdjacents = new()",
		"",
		";compute blocks to place.",
		"repeat (spreads:",
			"SpreadingPos from = nextSpreadingPos()",
			"if (from == null: break())",
			"for (int direction in range[0, 6):",
				";if (dot(primary, secondary) != 0: continue())",
				"if (direction & ~1 == from.direction & ~1: continue())",
				"int*(",
					"primaryX = directionX(direction)",
					"primaryY = directionY(direction)",
					"primaryZ = directionZ(direction)",
					"secondaryX = directionX(from.direction)",
					"secondaryY = directionY(from.direction)",
					"secondaryZ = directionZ(from.direction)",
				")",
				"BlockState adjacentState = getBlockState(",
					"from.x + primaryX,",
					"from.y + primaryY,",
					"from.z + primaryZ",
				")",
				"if (adjacentState.isReplaceable():",
					"BlockState adjacenterState = getBlockState(",
						"from.x + primaryX + secondaryX,",
						"from.y + primaryY + secondaryY,",
						"from.z + primaryZ + secondaryZ",
					")",
					"if (adjacenterState.blocksLight():",
						"addSpreadingPos(",
							"SpreadingPos.new(",
								"from.x + primaryX,",
								"from.y + primaryY,",
								"from.z + primaryZ,",
								"from.direction",
							")",
						")",
					")",
					"else if (adjacenterState.isReplaceable():",
						"addSpreadingPos(",
							"SpreadingPos.new(",
								"from.x + primaryX + secondaryX,",
								"from.y + primaryY + secondaryY,",
								"from.z + primaryZ + secondaryZ,",
								"byte(direction # 1)",
							")",
						")",
					")",
				")",
				"else if (adjacentState.blocksLight():",
					"addSpreadingPos(",
						"SpreadingPos.new(",
							"from.x,",
							"from.y,",
							"from.z,",
							"direction.as(byte)",
						")",
					")",
				")",
			")",
		")",
		"",
		";place blocks.",
		"",
		"void placeVeinsAround(SpreadingPos pos, int primary:",
			"int*(",
				"primaryX = pos.x + directionX(primary)",
				"primaryY = pos.y + directionY(primary)",
				"primaryZ = pos.z + directionZ(primary)",
			")",
			"BlockState adjacentState = getBlockState(",
				"primaryX + directionX(pos.direction),",
				"primaryY + directionY(pos.direction),",
				"primaryZ + directionZ(pos.direction)",
			")",
			"if (adjacentState.blocksLight() && adjacentState !==. 'minecraft:sculk':",
				"BlockState old = getBlockState(primaryX, primaryY, primaryZ)",
				"if (old.getBlock() ===. 'minecraft:sculk_vein':",
					"BlockState new = old.with(",
						"switch (pos.direction:",
							"case (0: 'west' )",
							"case (1: 'east' )",
							"case (2: 'down' )",
							"case (3: 'up'   )",
							"case (4: 'north')",
							"case (5: 'south')",
							"default ('???'  )",
						"),",
						"true",
					")",
					"if (old !== new:",
						"setBlockState(primaryX, primaryY, primaryZ, new)",
					")",
				")",
				"else if (old.isReplaceable():",
					"setBlockState(",
						"primaryX,",
						"primaryY,",
						"primaryZ,",
						"BlockState(",
							"'minecraft:sculk_vein',",
							"west:  pos.direction == 0,",
							"east:  pos.direction == 1,",
							"down:  pos.direction == 2,",
							"up:    pos.direction == 3,",
							"north: pos.direction == 4,",
							"south: pos.direction == 5,",
							"waterlogged: old.hasWater()",
						")",
					")",
				")",
			")",
		")",
		"",
		"void removeVeinsAround(int*(x, y, z):",
			"for (int checkDir in range[0, 6):",
				"int*(",
					"checkX = x + directionX(checkDir),",
					"checkY = y + directionY(checkDir),",
					"checkZ = z + directionZ(checkDir)",
				")",
				"BlockState old = getBlockState(checkX, checkY, checkZ)",
				"if (old.getBlock() ===. 'minecraft:sculk_vein':",
					"BlockState new = old.with(",
						"switch (checkDir # 1:",
							"case (0: 'west' )",
							"case (1: 'east' )",
							"case (2: 'down' )",
							"case (3: 'up'   )",
							"case (4: 'north')",
							"case (5: 'south')",
							"default ('???'  )",
						"),",
						"false",
					")",
					"if (new !== old:",
						"if (new ===. 'minecraft:sculk_vein[north=false,south=false,east=false,west=false,up=false,down=false,waterlogged=false]':",
							"new = 'minecraft:air'",
						")",
						"else if (new ===. 'minecraft:sculk_vein[north=false,south=false,east=false,west=false,up=false,down=false,waterlogged=true]':",
							"new = 'minecraft:water[level=0]'",
						")",
						"setBlockState(checkX, checkY, checkZ, new)",
					")",
				")",
			")",
		")",
		"",
		"for (SpreadingPos pos in sculkPosAdjacents:",
			"for (int direction in range[0, 6):",
				"if (direction == pos.direction # 1:",
					"continue()",
				")",
				"else if (direction == pos.direction:",
					"int*(",
						"adjacentX = pos.x + directionX(direction)",
						"adjacentY = pos.y + directionY(direction)",
						"adjacentZ = pos.z + directionZ(direction)",
					")",
					"if (getBlockState(adjacentX, adjacentY, adjacentZ).isIn('#bigglobe:sculk_replaceable'):",
						"setBlockState(adjacentX, adjacentY, adjacentZ, 'minecraft:sculk')",
					")",
					"removeVeinsAround(adjacentX, adjacentY, adjacentZ)",
				")",
				"else (",
					"placeVeinsAround(pos, direction)",
				")",
			")",
			"if (",
				"random.nextInt(64) == 0 &&",
				"BlockState*(centered := getBlockState(pos.x, pos.y, pos.z)).isReplaceable() &&",
				"getBlockState(pos.x, pos.y - 1, pos.z).blocksLight()",
			":",
				"setBlockState(pos.x, pos.y, pos.z,",
					"random.if (BlockState('minecraft:sculk_sensor', power: 0, sculk_sensor_phase: 'inactive', waterlogged: centered.hasWater()))",
					"else random.if ('minecraft:sculk_catalyst[bloom=false]')",
					"else (BlockState('minecraft:sculk_shrieker', can_summon: true, shrieking: false, waterlogged: centered.hasWater()))",
				")",
			")",
		")",
		"return(true)"
	],
	"inputs": [
		{ "name": "spreads", "type": "int" }
	]
}