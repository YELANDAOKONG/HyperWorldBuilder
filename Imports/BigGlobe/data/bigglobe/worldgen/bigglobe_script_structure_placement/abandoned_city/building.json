{
	"raw_placement": [
		"int adj = data.adj",
		"BlockState logState = WoodPalette(data.palette.asString()).strippedLogState(axis: 'y')",
		"int flag(int*(x, y, z):",
			"1 << (y * 9 + (z + 1) * 3 + (x + 1))",
		")",
		"boolean has(int*(x, y, z):",
			"adj & flag(x, y, z) != 0",
		")",
		"long posSeed(int*(x, y, z):",
			"(worldSeed # 16x425397BA502FBC3BUL).newSeed(",
				"transformX(x, y, z),",
				"transformY(x, y, z),",
				"transformZ(x, y, z)",
			")",
		")",
		"for (int*(x, z) in range[-2, 2]:",
			"int*(x1 = sign(x), z1 = sign(z), x2 = x - x1, z2 = z - z1)",
			"long posSeed(int y: posSeed(x, y, z))",
			"void ledge(:",
				"setBlockStateReplaceable(x, 4, z, 'minecraft:smooth_stone_slab[type=double,waterlogged=false]')",
				"if (setBlockStateReplaceable(x, 5, z, 'minecraft:cobblestone_wall[north=none,south=none,east=none,west=none,up=true,waterlogged=false]'):",
					"updateBlockState(x, 5, z)",
				")",
			")",
			"void stone(:",
				"setBlockStateReplaceable(x, 4, z,",
					"long seed = posSeed(4)",
					"(seed =: seed.newSeed()).if (0.75I: 'minecraft:stone')",
					"else seed.if ('minecraft:cobblestone')",
					"else ('minecraft:andesite')",
				")",
				"if (",
					"!has(0, 1, 0) &&",
					"random.nextBoolean(world_traits.`bigglobe:snow_chance`(x, z)) &&",
					"BlockState*(old := getBlockState(x, 5, z)).isReplaceable() &&",
					"old.getBlock() !=. 'minecraft:snow' ;why does snow count as replaceable even when it has more than one layer?",
				":",
					"setBlockState(x, 5, z, 'minecraft:snow[layers=1]')",
				")",
			")",
			"void log(: fillBlockStateReplaceable(x, 0, z, x, 3, z, logState))",
			"void brick(:",
				"void brick(int y:",
					"setBlockStateReplaceable(x, y, z,",
						"long seed = posSeed(y)",
						"(seed =: seed.newSeed()).if (0.75I: 'minecraft:stone_bricks')",
						"else seed.if ('minecraft:cracked_stone_bricks')",
						"else ('minecraft:mossy_stone_bricks')",
					")",
				")",
				"brick(0)",
				"if (x == 0 || z == 0 && random.nextBoolean():",
					"if (setBlockStateReplaceable(x, 1, z, 'minecraft:glass_pane[north=false,south=false,east=false,west=false,waterlogged=false]'):",
						"updateBlockState(x, 1, z)",
					")",
					"if (setBlockStateReplaceable(x, 2, z, 'minecraft:glass_pane[north=false,south=false,east=false,west=false,waterlogged=false]'):",
						"updateBlockState(x, 2, z)",
					")",
				")",
				"else (",
					"brick(1)",
					"brick(2)",
				")",
				"brick(3)",
			")",
			"void upperLog(: setBlockStateReplaceable(x, 4, z, logState))",
			"void upperBrick(: setBlockStateReplaceable(x, 4, z, 'minecraft:stone_bricks'))",
			"",
			"switch (x ^ 2 + z ^ 2:",
				"case (0:",
					"stone()",
				")",
				"case (1:",
					"unless (has(x1, 0, z1): brick())",
					"if (has(0, 1, 0) && !has(x1, 0, z1): upperBrick())",
					"else (stone())",
				")",
				"case (2:",
					"unless (has(x1, 0, z1) && has(x1, 0, 0) && has(0, 0, z1): brick())",
					"if (has(0, 1, 0) && (!has(x1, 0, 0) || !has(0, 0, z1)): upperBrick())",
					"else (stone())",
				")",
				"case (4:",
					"if (has(x2, 0, z2) || has(x2, 1, z2): stone())",
					"else unless (has(0, 1, 0): ledge())",
				")",
				"case (5:",
					"if (has(x2, 0, z2) || has(x2, 1, z2):",
						"boolean log = !(has(x1, 0, z1) && has(x1, 0, 0) && has(0, 0, z1))",
						"if (log: brick())",
						"if (log && has(0, 1, 0) && has(x2, 1, z2): upperBrick())",
						"else (stone())",
					")",
					"else unless (has(0, 1, 0):",
						"ledge()",
					")",
				")",
				"case (8:",
					"unless (has(x1, 0, z1) && has(x1, 0, 0) && has(0, 0, z1):",
						"log()",
						"if (has(0, 1, 0) || has(x1, 1, 0) || has(0, 1, z1) || has(x1, 1, z1): upperLog())",
						"else (ledge())",
					")",
					"else (stone())",
				")",
			")",
		")",
		"unless (has(0, 1, 0):",
			"unless (has(1, 0, 0):",
				"unless (has(1, 0, -1) || has(0, 1, -1):",
					"setBlockStateReplaceable(3, 4, -2, 'minecraft:stone_button[face=wall,facing=east,powered=false]')",
				")",
				"unless (has(1, 0, 1) || has(0, 1, 1):",
					"setBlockStateReplaceable(3, 4, 2, 'minecraft:stone_button[face=wall,facing=east,powered=false]')",
				")",
			")",
			"unless (has(-1, 0, 0):",
				"unless (has(-1, 0, -1) || has(0, 1, -1):",
					"setBlockStateReplaceable(-3, 4, -2, 'minecraft:stone_button[face=wall,facing=west,powered=false]')",
				")",
				"unless (has(-1, 0, 1) || has(0, 1, 1):",
					"setBlockStateReplaceable(-3, 4, 2, 'minecraft:stone_button[face=wall,facing=west,powered=false]')",
				")",
			")",
			"unless (has(0, 0, 1):",
				"unless (has(-1, 0, 1) || has(-1, 1, 0):",
					"setBlockStateReplaceable(-2, 4, 3, 'minecraft:stone_button[face=wall,facing=south,powered=false]')",
				")",
				"unless (has(1, 0, 1) || has(1, 1, 0):",
					"setBlockStateReplaceable(2, 4, 3, 'minecraft:stone_button[face=wall,facing=south,powered=false]')",
				")",
			")",
			"unless (has(0, 0, -1):",
				"unless (has(-1, 0, -1) || has(-1, 1, 0):",
					"setBlockStateReplaceable(-2, 4, -3, 'minecraft:stone_button[face=wall,facing=north,powered=false]')",
				")",
				"unless (has(1, 0, -1) || has(1, 1, 0):",
					"setBlockStateReplaceable(2, 4, -3, 'minecraft:stone_button[face=wall,facing=north,powered=false]')",
				")",
			")",
		")",
		"switch (data.deco.asInt():",
			"case (1:",
				"fillBlockStateReplaceable(0, 0, 0, 0, 3, 0, 'minecraft:andesite_wall[north=none,south=none,east=none,west=none,up=true,waterlogged=false]')",
			")",
			"case (2:",
				"setBlockState(0, 3, 0, 'minecraft:redstone_lamp[lit=false]')",
				"Coordinator.new().rotate4x90().setBlockState(1, 3, 0, 'minecraft:polished_andesite_stairs[facing=west,half=top,shape=straight,waterlogged=false]')",
				"setBlockStateReplaceable(0, 2, 0, BlockState('minecraft:lever', powered: false, face: 'ceiling', facing: random.switch ('north', 'south', 'east', 'west')))",
			")",
		")"
	],
	"placement": [
		"repeat (4:",
			"placeFeature(",
				"random.nextInt(-3, 4),",
				"random.nextInt(5),",
				"random.nextInt(-3, 4),",
				"'minecraft:vines'",
			")",
		")"
	]
}