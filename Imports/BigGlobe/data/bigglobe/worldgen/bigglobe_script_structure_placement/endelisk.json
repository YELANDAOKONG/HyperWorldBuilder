{
	"raw_placement": [
		";transfer NBT data to dedicated object for performance.",
		"class Offset(float*(x, y, z))",
		"ArrayList offsets = new(data.sides.size)",
		"for (NbtCompound nbt in data.sides.as(NbtList):",
			"offsets.add(Offset.new(nbt.x.as(float), nbt.y.as(float), nbt.z.as(float)))",
		")",
		"float radius = data.radius",
		"int ringColorOffset = (worldSeed # 16xBD3CB0913C4425ECUL).nextInt(12)",
		"int*(",
			"iterMinX = max(minX, chunkMinX)",
			"iterMinY = max(minY, chunkMinY)",
			"iterMinZ = max(minZ, chunkMinZ)",
			"iterMaxX = min(maxX, chunkMaxX)",
			"iterMaxY = min(maxY, chunkMaxY)",
			"iterMaxZ = min(maxZ, chunkMaxZ)",
		")",
		"BlockState filler = data.filler.asString().as(BlockState)",
		"BlockState accent = data.accent.asString().as(BlockState)",
		"NumberArray noiseSamples = newFloatArray(iterMaxY - iterMinY + 1)",
		"for positionLoop (",
			"int z in range[iterMinZ, iterMaxZ],",
			"int x in range[iterMinX, iterMaxX]",
		":",
			"long xzSeed = (worldSeed # 16x77D2024279677181UL).newSeed(x, z)",
			"float relativeX = x - midX",
			"float relativeZ = z - midZ",
			"float xzRadius2 = relativeX ^ 2 + relativeZ ^ 2",
			"Grid3D('bigglobe:obelisk_noise').getValuesY(worldSeed # 16xAA723C2B7936430FUL, x, iterMinY, z, noiseSamples)",
			"for yLoop (int y in range[iterMinY, iterMaxY]:",
				"float relativeY = y - midY",
				"float maxFrac = 0.0I",
				"for (Offset side in offsets:",
					"float dot = relativeX * side.x + relativeY * side.y + relativeZ * side.z",
					"float div = side.x ^ 2 + side.y ^ 2 + side.z ^ 2",
					"dot /= div",
					"if (dot > 1.015625I: continue(yLoop))",
					"maxFrac = max(maxFrac, dot)",
				")",
				"if (maxFrac < 0.875I: ;inside",
					"float xyzRadius = sqrt(xzRadius2 + relativeY ^ 2).as(float)",
					"float fractionalIndex = xyzRadius / radius * offsets.size * 2.0I",
					"int index = int(fractionalIndex) - 1",
					"if (index < 0:",
						"if (xyzRadius < 1.5I:",
							"long xyzSeed = xzSeed.newSeed(y)",
							"setBlockState(x, y, z,",
								"xyzSeed.nextInt() & 1 == 0",
								"? 'bigglobe:void_cloud'",
								": 'bigglobe:omni_aura_infused_void_cloud'",
							")",
						")",
					")",
					"else if (index < offsets.size:",
						"Offset normal = offsets.(index)",
						"float dot = (relativeX * normal.x + relativeY * normal.y + relativeZ * normal.z) / radius",
						";yes, I know this is not the normal formula for a torus,",
						";but it's close enough for my purposes.",
						"if ((fractionalIndex - index - 0.5I) ^ 2 + 0.25I * dot ^ 2 < 1.0I:",
							"long xyzSeed = xzSeed.newSeed(y)",
							"setBlockState(x, y, z,",
								"xyzSeed.nextInt(32) != 0",
								"? 'bigglobe:void_cloud'",
								": switch ((index + ringColorOffset) % 12:",
									"case ( 0: 'bigglobe:red_aura_infused_void_cloud')",
									"case ( 1: 'bigglobe:orange_aura_infused_void_cloud')",
									"case ( 2: 'bigglobe:yellow_aura_infused_void_cloud')",
									"case ( 3: 'bigglobe:yellow_green_aura_infused_void_cloud')",
									"case ( 4: 'bigglobe:green_aura_infused_void_cloud')",
									"case ( 5: 'bigglobe:cyan_green_aura_infused_void_cloud')",
									"case ( 6: 'bigglobe:cyan_aura_infused_void_cloud')",
									"case ( 7: 'bigglobe:cyan_blue_aura_infused_void_cloud')",
									"case ( 8: 'bigglobe:blue_aura_infused_void_cloud')",
									"case ( 9: 'bigglobe:purple_aura_infused_void_cloud')",
									"case (10: 'bigglobe:magenta_aura_infused_void_cloud')",
									"case (11: 'bigglobe:magenta_red_aura_infused_void_cloud')",
									"default ('bigglobe:void_cloud')",
								")",
							")",
						")",
					")",
				")",
				"else ( ;outside",
					"float noise = noiseSamples.(y - minY).as(float) * 0.015625I",
					"if (maxFrac - noise < 1.0I:",
						"setBlockState(x, y, z, filler)",
					")",
					"else if (maxFrac + noise + 0.0625I < 1.0I:",
						"setBlockState(x, y, z, accent)",
					")",
				")",
			")",
		")"
	],
	"placement": "noop"
}