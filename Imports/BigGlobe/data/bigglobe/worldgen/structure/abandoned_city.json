{
	"type": "bigglobe:script",
	"biomes": "#bigglobe:has_structure/abandoned_city",
	"spawn_overrides": {},
	"step": "surface_structures",
	"layout": [
		"String palette = (",
			"world_traits.`bigglobe:wood_palette`(",
				"originX,",
				"world_traits.`bigglobe:y_level_on_surface`(originX, originZ),",
				"originZ",
			")",
			".?id",
			"?: return()",
		")",
		"int*(",
			"BASE_SIZE    = random.nextInt(16)",
			"MAX_RADIUS   = BASE_SIZE + 8",
			"MAX_DIAMETER = MAX_RADIUS * 2 + 1",
			"MAX_AREA     = MAX_DIAMETER ^ 2",
			"originY      = 16x7FFF_FFFFU",
			"highestY     = 16x8000_0000U",
		")",
		"int realX(int rawX: rawX * 4 + originX)",
		"int realY(int rawY: rawY * 5 + originY)",
		"int realZ(int rawZ: rawZ * 4 + originZ)",
		"for (int*(rawZ, rawX) in range[-MAX_RADIUS, MAX_RADIUS]:",
			"int*(",
				"x = realX(rawX)",
				"z = realZ(rawZ)",
				"y = world_traits.`bigglobe:y_level_in_surface`(x, z)",
			")",
			"if (world_traits.`bigglobe:biome`(x, y, z).isIn('#bigglobe:has_structure/abandoned_city'):",
				"originY = min(originY, y)",
				"highestY = max(highestY, y)",
			")",
		")",
		"if (originY == 16x7FFF_FFFF: return())",
		"int*(",
			"MAX_LAYERS = (highestY - originY) / 5 + 12",
			"MAX_VOLUME = MAX_AREA * MAX_LAYERS",
		")",
		"NumberArray positions = newBooleanArray(MAX_VOLUME)",
		"int encodeIndex(int*(x, y, z):",
			"y * MAX_AREA + (z + MAX_RADIUS) * MAX_DIAMETER + (x + MAX_RADIUS)",
		")",
		"boolean hasAt(int*(x, y, z):",
			"x.isBetween[-MAX_RADIUS, MAX_RADIUS] &&",
			"z.isBetween[-MAX_RADIUS, MAX_RADIUS] &&",
			"(y < 0 || (y < MAX_LAYERS && positions.(encodeIndex(x, y, z))))",
		")",
		"boolean hasAtIncludingTerrain(int*(x, y, z):",
			"x.isBetween[-MAX_RADIUS, MAX_RADIUS] &&",
			"z.isBetween[-MAX_RADIUS, MAX_RADIUS] &&",
			"(",
				"y < 0 || ;shouldn't be necessary, but for some reason still is???",
				"realY(y) + 4 <= world_traits.`bigglobe:y_level_on_surface`(realX(x), realZ(z)) ||",
				"(y < MAX_LAYERS && positions.(encodeIndex(x, y, z)))",
			")",
		")",
		"int countAdjacents(int*(rawX, rawY, rawZ):",
			"int adj = 0",
			"int shift = 0",
			"for (int offsetY in range[0, 1], int*(offsetZ, offsetX) in range[-1, 1]:",
				"adj |= int(hasAt(rawX + offsetX, rawY + offsetY, rawZ + offsetZ)) << ++:shift",
			")",
			"adj",
		")",
		"boolean isStaircaseColumn(int*(rawX, rawZ):",
			"int position = (worldSeed # 16xB878B31F02EC6F15UL).newSeed(rawX >> 3, rawZ >> 3).nextInt()",
			"return(position & 2x11 == rawX & 2x111 && (position >>> 1) & 2x11 == rawZ & 2x111)",
		")",
		"boolean isStaircaseAt(int*(rawX, rawY, rawZ, adjacents):",
			"return(",
				"isStaircaseColumn(rawX, rawZ) &&",
				"adjacents == 2x111_111_111___111_111_111",
			")",
		")",
		"for (int layer in range[0, MAX_LAYERS):",
			"boolean canPlace(int*(rawX, rawZ):",
				"unless (hasAtIncludingTerrain(rawX, layer - 1, rawZ): return(false))",
				"if (hasAt(rawX, layer, rawZ): return(false))",
				"return(true)",
			")",
			"boolean canFill(int*(minX, minZ, maxX, maxZ):",
				"for (int z in range[minZ, maxZ], int x in range[minX, maxX]:",
					"unless (canPlace(x, z): return(false))",
				")",
				"return(true)",
			")",
			"for (int placementAttempt in range[0, layer * MAX_RADIUS + MAX_RADIUS):",
				"int*(",
					"centerX = random.nextInt(-MAX_RADIUS, MAX_RADIUS + 1)",
					"centerZ = random.nextInt(-MAX_RADIUS, MAX_RADIUS + 1)",
					"minX = centerX",
					"maxX = centerX",
					"minZ = centerZ",
					"maxZ = centerZ",
				")",
				"if (canPlace(centerX, centerZ):",
					"for (int directions = 2x1111, directions != 0, noop:",
						"random.switch (",
							"if (directions & 2x1000 != 0: canFill(minX - 1, minZ, minX - 1, maxZ) ? --minX : directions &= 2x0111),",
							"if (directions & 2x0100 != 0: canFill(maxX + 1, minZ, maxX + 1, maxZ) ? ++maxX : directions &= 2x1011),",
							"if (directions & 2x0010 != 0: canFill(minX, minZ - 1, maxX, maxZ - 1) ? --minZ : directions &= 2x1101),",
							"if (directions & 2x0001 != 0: canFill(minX, maxZ + 1, maxX, maxZ + 1) ? ++maxZ : directions &= 2x1110)",
						")",
					")",
					"if (minX == maxX || minZ == maxZ: continue())",
					"int*(",
						"sizeX = max(random.nextInt(maxX - minX + 1), random.nextInt(maxX - minX + 1))",
						"sizeZ = max(random.nextInt(maxZ - minZ + 1), random.nextInt(maxZ - minZ + 1))",
					")",
					"random.if (",
						"random.if (maxX = minX + sizeX) else (minX = maxX - sizeX)",
						"minZ = random.nextInt(minZ, maxZ + 1 - sizeZ)",
						"maxZ = minZ + sizeZ",
					")",
					"else (",
						"random.if (maxZ = minZ + sizeZ) else (minZ = maxZ - sizeZ)",
						"minX = random.nextInt(minX, maxX + 1 - sizeX)",
						"maxX = minX + sizeX",
					")",
					"for (int z in range[minZ, maxZ]:",
						"int from = encodeIndex(minX, layer, z)",
						"int to = encodeIndex(maxX, layer, z)",
						"positions.fillBoolean(from, to + 1, true)",
					")",
				")",
			")",
		")",
		"for (int*(rawZ, rawX) in range[-MAX_RADIUS, MAX_RADIUS]:",
			"int surfaceY = world_traits.`bigglobe:y_level_on_surface`(realX(rawX), realZ(rawZ))",
			"boolean biomeIncorrect = !world_traits.`bigglobe:biome`(realX(rawX), surfaceY, realZ(rawZ)).isIn('#bigglobe:has_structure/abandoned_city')",
			"for (int layer = 0, layer < MAX_LAYERS && (surfaceY > realY(layer) + 4 || biomeIncorrect), ++layer:",
				"positions.(encodeIndex(rawX, layer, rawZ)) = false",
			")",
		")",
		"void fillGaps(int*(rawX, layer, rawZ), boolean filling:",
			"boolean hasAtMaybeTerrain(int*(x, y, z):",
				"filling ? hasAt(x, y, z) : hasAtIncludingTerrain(x, y, z)",
			")",
			"if (",
				"hasAt(rawX, layer, rawZ) != filling && (",
					"(",
						"hasAtMaybeTerrain(rawX - 1, layer, rawZ) == filling &&",
						"hasAtMaybeTerrain(rawX + 1, layer, rawZ) == filling",
					")",
					"|| (",
						"hasAtMaybeTerrain(rawX, layer, rawZ - 1) == filling &&",
						"hasAtMaybeTerrain(rawX, layer, rawZ + 1) == filling",
					")",
				")",
			":",
				"positions.(encodeIndex(rawX, layer, rawZ)) = filling",
				"fillGaps(rawX - 1, layer, rawZ, filling)",
				"fillGaps(rawX, layer, rawZ - 1, filling)",
			")",
		")",
		"for (int layer in range[0, MAX_LAYERS), int*(rawZ, rawX) in range[-MAX_RADIUS, MAX_RADIUS]:",
			"fillGaps(rawX, layer, rawZ, true)",
		")",
		"for (int layer in -range[0, MAX_LAYERS), int*(rawZ, rawX) in range[-MAX_RADIUS, MAX_RADIUS]:",
			"fillGaps(rawX, layer, rawZ, false)",
		")",
		"NumberArray outdoorStaircases = newBooleanArray(MAX_VOLUME)",
		"for (int rawY in range[0, MAX_LAYERS), int*(rawZ, rawX) in range[-MAX_RADIUS, MAX_RADIUS]:",
			"int*(x = realX(rawX), y = realY(rawY), z = realZ(rawZ))",
			"if (hasAt(rawX, rawY, rawZ):",
				"int adj = countAdjacents(rawX, rawY, rawZ)",
				"pieces.add(",
					"isStaircaseAt(rawX, rawY, rawZ, adj)",
					"? (",
						"long seed = (worldSeed # 16x534C2016F8A7E2B3UL).newSeed(rawX, rawZ)",
						"boolean spiral = (seed := seed.newSeed()).nextBoolean()",
						"ScriptStructurePiece piece = ScriptStructurePiece.new(",
							"-2, 0, -2, 2, 5, 2,",
							"spiral",
							"? 'bigglobe:abandoned_city/indoor_staircase_spiral'",
							": 'bigglobe:abandoned_city/indoor_staircase_straight',",
							"nbtCompound(",
								"palette: palette,",
								"up: countAdjacents(rawX, rawY + 1, rawZ) == 2x111_111_111___111_111_111",
							")",
						")",
						"if (spiral: piece.withRotation(((seed := seed.newSeed()).nextInt(4) + rawY) * 90))",
						"else (piece.rotateRandomly(seed := seed.newSeed()))",
						"(seed := seed.newSeed()).if (piece.symmetrifyAround(0, 0, 'FLIP_0'))",
						"piece.offset(x, y, z)",
					")",
					": ScriptStructurePiece.new(",
						"-3, 0, -3, 3, 5, 3,",
						"'bigglobe:abandoned_city/building',",
						"nbtCompound(",
							"adj: adj,",
							"deco: if (adj & 2x111_111_111 == 2x111_111_111:",
								"if (isStaircaseColumn(rawX, rawZ) && countAdjacents(rawX, rawY - 1, rawZ) == 2x111_111_111___111_111_111: 0Y)",
								"else if (rawX | rawZ & 1 == 0: 1Y)",
								"else if (rawX & rawZ & 1 == 1: 2Y)",
								"else (0Y)",
							")",
							"else (",
								"random.nextBoolean() ? 3Y : 0Y",
							"),",
							"palette: palette",
						")",
					")",
					".offset(x, y, z)",
				")",
			")",
			"else if (rawX # rawZ & 1 == 0 && hasAt(rawX, rawY - 1, rawZ):",
				"int*(dx = 0, dz = 0, rotation = 0)",
				"random.switch (",
					"dz =  1 rotation =   0,",
					"dx = -1 rotation =  90,",
					"dz = -1 rotation = 180,",
					"dx =  1 rotation = 270",
				")",
				"if (",
					" hasAt(rawX + dx, rawY,     rawZ + dz) &&",
					"!hasAt(rawX + dx, rawY + 1, rawZ + dz) &&",
					" hasAt(rawX - dx, rawY - 1, rawZ - dz) &&",
					"!hasAt(rawX - dx, rawY,     rawZ - dz)",
				":",
					"pieces.add(",
						"ScriptStructurePiece.new(",
							"-2, 0, -2, 2, 5, 2,",
							"'bigglobe:abandoned_city/outdoor_staircase',",
							"nbtCompound(",
								"l: hasAt(rawX + dz, rawY, rawZ - dx),",
								"r: hasAt(rawX - dz, rawY, rawZ + dx)",
							")",
						")",
						".withRotation(rotation)",
						".offset(x, y, z)",
					")",
					"outdoorStaircases.(encodeIndex(rawX, rawY, rawZ)) = true",
				")",
			")",
		")",
		"boolean hasOrStaircase(int*(x, y, z):",
			"x.isBetween[-MAX_RADIUS, MAX_RADIUS] &&",
			"z.isBetween[-MAX_RADIUS, MAX_RADIUS] &&",
			"(",
				"y < 0 || (",
					"y < MAX_LAYERS && (",
						"int index = encodeIndex(x, y, z),,",
						"positions.(index) || outdoorStaircases.(index)",
					")",
				")",
			")",
		")",
		"NumberArray roofPositions = newBooleanArray(MAX_VOLUME)",
		"boolean hasRoofAt(int*(x, y, z):",
			"roofPositions.(encodeIndex(x, y, z))",
		")",
		"for outer (int rawY in range[0, MAX_LAYERS), int*(rawZ, rawX) in range[-MAX_RADIUS, MAX_RADIUS]:",
			"for (int*(offsetX, offsetZ) in range[-1, 1]:",
				"unless (hasAt(rawX + offsetX, rawY, rawZ + offsetZ): continue(outer))",
				"if (hasOrStaircase(rawX + offsetX, rawY + 1, rawZ + offsetZ): continue(outer))",
			")",
			"roofPositions.(encodeIndex(rawX, rawY, rawZ)) = true",
		")",
		"for (int rawY in range[0, MAX_LAYERS), int*(rawZ, rawX) in range[-MAX_RADIUS, MAX_RADIUS]:",
			"int*(x = realX(rawX), y = realY(rawY), z = realZ(rawZ))",
			"if (hasAt(rawX, rawY, rawZ):",
				"int*(dx = 0, dz = 0, rotation = 0)",
				"random.switch (",
					"dz =  1 rotation =   0,",
					"dx = -1 rotation =  90,",
					"dz = -1 rotation = 180,",
					"dx =  1 rotation = 270",
				")",
				"unless (hasOrStaircase(rawX - dx, rawY, rawZ - dz):",
					"pieces.add(",
						"hasAt(rawX - dx, rawY - 1, rawZ - dz)",
						"? ScriptStructurePiece.new(",
							"-2, 0, -2, 2, 2, 2,",
							"'bigglobe:abandoned_city/door',",
							"nbtCompound()",
						")",
						".withRotation(rotation)",
						".offset(x, y, z)",
						": ScriptStructurePiece.new(",
							"0, 0, 0, 0, 3, 0,",
							"'bigglobe:abandoned_city/interior_wall',",
							"nbtCompound()",
						")",
						".offset(x, y, z)",
					")",
				")",
			")",
			"if (hasRoofAt(rawX, rawY, rawZ):",
				"pieces.add(",
					"ScriptStructurePiece.new(",
						"-2, 0, -2, 2, 1, 2,",
						"'bigglobe:abandoned_city/roof',",
						"nbtCompound(",
							"adj: (",
								"int adj = 0",
								"int shift = 0",
								"for (int*(offsetZ, offsetX) in range[-1, 1]:",
									"adj |= int(hasRoofAt(rawX + offsetX, rawY, rawZ + offsetZ)) << ++:shift",
								")",
								"adj",
							"),",
							"palette: palette",
						")",
					")",
					".offset(x, y + 5, z)",
				")",
			")",
		")"
	]
}