{
	"script": [
		"unless (maxWavelength > minWavelength: return(0.0L))",
		"if (preNormalize:",
			"double magnitude = sqrt(dx ^ 2 + dz ^ 2)",
			"if (magnitude == 0.0L: return(0.0L))",
			"dx /= magnitude",
			"dz /= magnitude",
		")",
		"double*(",
			"result       = 0.0L",
			"theta        = seed.nextDouble(tau)",
			"unitX        = cos(theta)",
			"unitZ        = sin(theta)",
			"goldenCos    = cos(goldenAngle)",
			"goldenSin    = sin(goldenAngle)",
			"decay        = 2.0L ^ (-1.0L / 64.0L)",
		")",
		"minWavelength /= tau",
		"maxWavelength /= tau",
		"for (double wavelength = maxWavelength, wavelength >= minWavelength, wavelength *= decay:",
			"double*(",
				"phase             = (seed := seed.newSeed()).nextDouble(tau)",
				"projection        = (unitX * x + unitZ * z) / wavelength + phase",
				"adjustedAmplitude = ((unitX * -dz + unitZ * dx) / (sqrt(dx ^ 2 + dz ^ 2) + dampening)) ^ 2",
				"addedValue        = fastSin(projection) * adjustedAmplitude * wavelength",
				"addedDerivative   = fastCos(projection) * adjustedAmplitude",
				"nextUnitX         = unitX * goldenCos + unitZ * -goldenSin",
				"nextUnitZ         = unitX * goldenSin + unitZ *  goldenCos",
			")",
			"result += addedValue",
			"dx     += addedDerivative * unitX",
			"dz     += addedDerivative * unitZ",
			"unitX   = nextUnitX",
			"unitZ   = nextUnitZ",
		")",
		"return(result * amplitude)"
	],
	"inputs": [
		{ "name": "dx", "type": "double" },
		{ "name": "dz", "type": "double" },
		{ "name": "minWavelength", "type": "double" },
		{ "name": "maxWavelength", "type": "double" },
		{ "name": "seed", "type": "long" },
		{ "name": "dampening", "type": "double", "default": "4.0L" },
		{ "name": "amplitude", "type": "double", "default": "1.0L" },
		{ "name": "preNormalize", "type": "boolean", "default": "false" }
	]
}