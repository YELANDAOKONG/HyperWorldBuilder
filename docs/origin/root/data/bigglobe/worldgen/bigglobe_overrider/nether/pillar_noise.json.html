<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Viewer - pillar_noise.json</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        :root {
            --primary-color: #4a6da7;
            --secondary-color: #8aa9d6;
            --accent-color: #ffb200;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --success-color: #28a745;
            --info-color: #17a2b8;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --folder-color: #ff9800;
            --folder-hover: #f57c00;
            --file-color: #9c27b0;
            --file-hover: #7b1fa2;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --code-background: #f8f9fa;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: var(--font-main);
            line-height: 1.6;
            color: var(--dark-color);
            background-color: var(--light-color);
            padding: 0;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            width: 100%;
            margin: 0;
            padding: 0;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        header {
            background-color: var(--file-color);
            color: white;
            padding: 1.5rem;
            margin: 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-image: linear-gradient(135deg, var(--file-color) 0%, var(--file-hover) 100%);
        }
        
        header h1 {
            margin: 0;
            font-size: 2rem;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
        }
        
        header h1 .file-icon {
            margin-right: 0.8rem;
        }
        
        .breadcrumb {
            background-color: white;
            padding: 1rem;
            margin: 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        
        .breadcrumb a {
            background-color: var(--secondary-color);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.3s;
            text-decoration: none;
            font-weight: 500;
        }
        
        .breadcrumb a:hover {
            background-color: var(--primary-color);
            text-decoration: none;
        }
        
        .breadcrumb span {
            padding: 0.5rem 1rem;
            background-color: #f0f0f0;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .code-container {
            background-color: var(--code-background);
            padding: 0;
            margin: 0;
            overflow: auto;
            flex: 1;
            position: relative;
        }
        
        pre {
            margin: 0;
            padding: 1rem;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            tab-size: 2;
        }
        
        code {
            white-space: pre;
            display: block;
        }
        
        .actions {
            position: sticky;
            top: 0;
            right: 0;
            display: flex;
            justify-content: flex-end;
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.9);
            border-bottom: 1px solid #ddd;
            z-index: 100;
        }
        
        .action-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            margin-left: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            transition: background-color 0.3s;
        }
        
        .action-button:hover {
            background-color: #395885;
        }
        
        .action-icon {
            margin-right: 0.5rem;
        }
        
        footer {
            padding: 1rem;
            text-align: center;
            color: var(--dark-color);
            font-size: 0.9rem;
            background-color: white;
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-file-code file-icon"></i> pillar_noise.json</h1>
        </header>
        
        <div class="breadcrumb">
            <a href="../../../../index.html">Main Index</a> <a href="../index.html">Root Root</a> <a href="index.html">data\bigglobe\worldgen\bigglobe_overrider\nether</a> <span>pillar_noise.json</span>
        </div>
        
        <div class="code-container">
            <div class="actions">
                <button onclick="copyToClipboard()" class="action-button">
                    <i class="fas fa-copy action-icon"></i> Copy
                </button>
            </div>
            <pre><code class="language-json">{
  &quot;type&quot;: &quot;column_value&quot;,
  &quot;script&quot;: [
    &quot;for (StructureStart start in structures:&quot;,
    &quot;if (start.structure.isIn(&#39;#bigglobe:nether_pillars&#39;):&quot;,
    &quot;for (ScriptStructurePiece piece in start.pieces:&quot;,
    &quot;class PillarData (&quot;,
    &quot;double*(&quot;,
    &quot;posX, posY, posZ,&quot;,
    &quot;negX, negY, negZ,&quot;,
    &quot;normX, normY, normZ,&quot;,
    &quot;length,&quot;,
    &quot;endRadius,&quot;,
    &quot;centerRadius&quot;,
    &quot;)&quot;,
    &quot;)&quot;,
    &quot;PillarData pillarData = new(&quot;,
    &quot;piece.data.posX.asDouble(),&quot;,
    &quot;piece.data.posY.asDouble(),&quot;,
    &quot;piece.data.posZ.asDouble(),&quot;,
    &quot;piece.data.negX.asDouble(),&quot;,
    &quot;piece.data.negY.asDouble(),&quot;,
    &quot;piece.data.negZ.asDouble(),&quot;,
    &quot;piece.data.normX.asDouble(),&quot;,
    &quot;piece.data.normY.asDouble(),&quot;,
    &quot;piece.data.normZ.asDouble(),&quot;,
    &quot;piece.data.length.asDouble(),&quot;,
    &quot;piece.data.endR.asDouble(),&quot;,
    &quot;piece.data.centerR.asDouble()&quot;,
    &quot;)&quot;,
    &quot;class Projector (&quot;,
    &quot;double*(&quot;,
    &quot;relativeX, relativeY, relativeZ,&quot;,
    &quot;dotX, dotY, dotZ, dot&quot;,
    &quot;projectionX, projectionY, projectionZ,&quot;,
    &quot;projectionDistanceSquared&quot;,
    &quot;)&quot;,
    &quot;)&quot;,
    &quot;Projector Projector.setX(double x:&quot;,
    &quot;this.=$dotX((this.relativeX := x - pillarData.negX) * pillarData.normX)&quot;,
    &quot;)&quot;,
    &quot;Projector Projector.setY(double y:&quot;,
    &quot;this.=$dotY((this.relativeY := y - pillarData.negY) * pillarData.normY)&quot;,
    &quot;)&quot;,
    &quot;Projector Projector.setZ(double z:&quot;,
    &quot;this.=$dotZ((this.relativeZ := z - pillarData.negZ) * pillarData.normZ)&quot;,
    &quot;)&quot;,
    &quot;Projector Projector.project(boolean clamp:&quot;,
    &quot;double dot = this.dotX + this.dotY + this.dotZ&quot;,
    &quot;if (clamp: dot = clamp(0.0L, pillarData.length, dot))&quot;,
    &quot;this.$=dot(dot).$=projectionDistanceSquared(&quot;,
    &quot;(this.relativeX - (this.projectionX := dot * pillarData.normX)) ^ 2 +&quot;,
    &quot;(this.relativeY - (this.projectionY := dot * pillarData.normY)) ^ 2 +&quot;,
    &quot;(this.relativeZ - (this.projectionZ := dot * pillarData.normZ)) ^ 2&quot;,
    &quot;)&quot;,
    &quot;)&quot;,
    &quot;double Projector.getExpectedRadius(:&quot;,
    &quot;mixLinear(pillarData.centerRadius, pillarData.endRadius, (this.dot / pillarData.length * 2.0L - 1.0L) ^ 2)&quot;,
    &quot;)&quot;,
    &quot;double Projector.getRadiusFractionSquared(:&quot;,
    &quot;double expectedRadius = this.getExpectedRadius()&quot;,
    &quot;return(expectedRadius &gt; 0.0L ? this.projectionDistanceSquared / expectedRadius ^ 2 : -1.0L)&quot;,
    &quot;)&quot;,
    &quot;Projector projector = new().setX(x).setZ(z)&quot;,
    &quot;;;&quot;,
    &quot;my claim is that the function&quot;,
    &quot;y -&gt; projector.setY(y).project(false).projectionDistance()&quot;,
    &quot;is a hyperbolic function. to prove this, we will look at a&quot;,
    &quot;different specialization of a more broad set of problems:&quot;,
    &quot;the closest point between 2 arbitrary lines.&quot;,
    &quot;say you have 2 lines, line1 and line2,&quot;,
    &quot;and a point on each of those lines,&quot;,
    &quot;point1 on line1, and point2 on line2.&quot;,
    &quot;which pair of points has the smallest distance between them?&quot;,
    &quot;for our first simplified case, assume line1&quot;,
    &quot;intersects the origin, and is aligned with the x axis.&quot;,
    &quot;also assume line2 intersects (0, 1, 0) and is aligned with the z axis.&quot;,
    &quot;for any given point2, the closest point to it on line1 will be the origin,&quot;,
    &quot;so the distance from point1 to point2 is:&quot;,
    &quot;sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2 + (z2 - z1) ^ 2)&quot;,
    &quot;= sqrt((0 - 0) ^ 2 + (1 - 0) ^ 2 + (z2 - 0) ^ 2)&quot;,
    &quot;= sqrt(0^2 + 1^2 + z2^2)&quot;,
    &quot;= sqrt(z2 ^ 2 + 1)&quot;,
    &quot;this is a hyperbola, as desired.&quot;,
    &quot;what if line2 intersects (0, 1, 0), but is no longer aligned with the z axis?&quot;,
    &quot;in this case, the closest point1 to it is (x2, 0, z2).&quot;,
    &quot;the distance then, is:&quot;,
    &quot;sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2 + (z2 - z1) ^ 2)&quot;,
    &quot;= sqrt((x2 - x2) ^ 2 + (1 - 0) ^ 2) + (z2 - 0) ^ 2)&quot;,
    &quot;= sqrt(0^2 + 1^2 + z2^2)&quot;,
    &quot;= sqrt(z2^2 + 1)&quot;,
    &quot;the x coordinates cancel each other out, and we still have a hyperbola.&quot;,
    &quot;final case: what if line2 intersects a different point besides (0, 1, 0)?&quot;,
    &quot;say, for example, (0, 4, 0)&quot;,
    &quot;I&#39;ll spare you the math, but the end result is:&quot;,
    &quot;sqrt(z2^2 + 16)&quot;,
    &quot;this is STILL a hyperbola.&quot;,
    &quot;to complete this proof, the last assumption we need is that changing&quot;,
    &quot;the orientation of space does not change the distance between 2 points.&quot;,
    &quot;so, any function which linearly maps a number to a point on line1, and then&quot;,
    &quot;point1 to its closest counterpart on line2, must be a hyperbolic function.&quot;,
    &quot;so... how does this proof help us figure out which Y levels need to have their noise values modified?&quot;,
    &quot;well, a pillar is a line, and a column is also a line.&quot;,
    &quot;so by definition, y -&gt; projector.setY(y).project(false).projectionDistance()&quot;,
    &quot;is a hyperbolic function.&quot;,
    &quot;additionally, y -&gt; projector.setY(y).project(false).projectionDistanceSquared will&quot;,
    &quot;be a parabolic function, because a hyperbola is just the square root of a parabola.&quot;,
    &quot;a parabolic function of y can be defined as ay^2 + by + c for some constants a, b, and c.&quot;,
    &quot;if we can find these constants, then we can directly deduce some properties of the parabola.&quot;,
    &quot;in particular, we can deduce its midpoint, and the interval of its domain&quot;,
    &quot;which is less than some threshold, by using the quadratic formula.&quot;,
    &quot;knowing this interval means we know which Y&quot;,
    &quot;levels are within some distance of the pillar.&quot;,
    &quot;the distance to the pillar that we need in order to modify&quot;,
    &quot;noise at changes based on where along the pillar we are,&quot;,
    &quot;but it does have an upper bound: endRadius.&quot;,
    &quot;at the very least, this vastly reduces the number of&quot;,
    &quot;y levels that we need to check in the first place.&quot;,
    &quot;sounds good in theory, but how do we actually find those constants from earlier?&quot;,
    &quot;well, we can directly query the parabola function at arbitrary Y levels,&quot;,
    &quot;and we only need 3 points to find a parabola which passes through all of them.&quot;,
    &quot;we can technically use any 3 points, but -1, 0, and 1 have the simplest math.&quot;,
    &quot;the system of equations that arise from these points is as follows:&quot;,
    &quot;a * (-1) ^ 2 + b * (-1) + c = (the distance squared at y = -1)&quot;,
    &quot;a * 0^2 + b * 0 + c = (the distance squared at y = 0)&quot;,
    &quot;a * 1^2 + b * 1 + c = (the distance squared at y = 1)&quot;,
    &quot;we have 3 equations, and 3 unknowns,&quot;,
    &quot;so this is a system which can be solved.&quot;,
    &quot;the solution is given in the code below.&quot;,
    &quot;;;&quot;,
    &quot;double distanceSquaredAtNegativeOne = projector.setY(-1).project(false).projectionDistanceSquared&quot;,
    &quot;double distanceSquaredAtZero        = projector.setY( 0).project(false).projectionDistanceSquared&quot;,
    &quot;double distanceSquaredAtOne         = projector.setY( 1).project(false).projectionDistanceSquared&quot;,
    &quot;double a = (distanceSquaredAtOne + distanceSquaredAtNegativeOne) * 0.5L - distanceSquaredAtZero&quot;,
    &quot;double b = (distanceSquaredAtOne - distanceSquaredAtNegativeOne) * 0.5L&quot;,
    &quot;double c = distanceSquaredAtZero&quot;,
    &quot;;;&quot;,
    &quot;the interval where the hyperbola is less than endRadius is the&quot;,
    &quot;same as the interval where the parabola is less than endRadius ^ 2.&quot;,
    &quot;the quadratic formula, (-b +/- sqrt(b^2 - 4ac)) / 2a,&quot;,
    &quot;can give the interval where the parabola is less than 0.&quot;,
    &quot;to get the interval where the parabola is less than&quot;,
    &quot;this.endRadius ^ 2, we simply need to subtract it from c.&quot;,
    &quot;;;&quot;,
    &quot;c -= 4.0L * pillarData.endRadius ^ 2&quot;,
    &quot;double sqrtTerm = b ^ 2 - 4.0L * a * c&quot;,
    &quot;if (sqrtTerm !&gt; 0.0L: continue()) ;interval is non-existent.&quot;,
    &quot;sqrtTerm = sqrt(sqrtTerm)&quot;,
    &quot;double div = 0.5L / a&quot;,
    &quot;int minY = ceilInt((-b - sqrtTerm) * div)&quot;,
    &quot;if (minY &gt;= `bigglobe:nether/max_y`: continue()) ;interval does not intersect the Y range we care about.&quot;,
    &quot;int maxY = floorInt((-b + sqrtTerm) * div)&quot;,
    &quot;if (maxY &lt; `bigglobe:nether/min_y`: continue()) ;interval does not intersect the Y range we care about.&quot;,
    &quot;minY = max(minY, piece.minY, `bigglobe:nether/min_y`)&quot;,
    &quot;maxY = min(maxY, piece.maxY, `bigglobe:nether/max_y`)&quot;,
    &quot;for (int y in range[minY, maxY]:&quot;,
    &quot;double fraction = projector.setY(y).project(true).getRadiusFractionSquared()&quot;,
    &quot;if (fraction.isBetween(0.0L, 4.0L):&quot;,
    &quot;fraction = abs(fraction * (1.0L / 3.0L) - (4.0L / 3.0L))&quot;,
    &quot;`bigglobe:nether/bubble`.noise(y) += float(fraction ^ 3)&quot;,
    &quot;)&quot;,
    &quot;)&quot;,
    &quot;)&quot;,
    &quot;)&quot;,
    &quot;)&quot;
  ]
}</code></pre>
        </div>
        
        <footer>
            <p>Generated by BigGlobe Decision Tree Documentation Builder</p>
        </footer>
    </div>
    
    <script>
        function copyToClipboard() {
            const codeElement = document.querySelector('code');
            const textArea = document.createElement('textarea');
            textArea.value = codeElement.textContent;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            // Show feedback
            const button = document.querySelector('.action-button');
            const originalText = button.innerHTML;
            button.innerHTML = '<i class="fas fa-check action-icon"></i> Copied!';
            setTimeout(() => {
                button.innerHTML = originalText;
            }, 2000);
        }
    </script>
</body>
</html>
